import unittest

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pickle as pickle
import sys
import time

from CARTGV import CARTGVTree, CARTGVTreeBuilder
from CARTGV import CARTGVSplitter, BaseDenseCARTGVSplitter, BestCARTGVSplitter
from CARTGV import CARTGVCriterion, CARTGVClassificationCriterion, CARTGVGini

from sklearn.utils.validation import check_random_state
from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor
from sklearn.tree import plot_tree
from sklearn.tree._tree import DepthFirstTreeBuilder, BestFirstTreeBuilder, Tree
from sklearn.tree._splitter import BestSplitter
from sklearn.tree._criterion import Gini, Entropy

from scipy.sparse import issparse
from numpy import float32 as DTYPE
from numpy import float64 as DOUBLE


# tree = CARTGVTree(n_grouped_features, n_classes, n_outputs)

# builder = CARTGVTreeBuilder(splitter, min_samples_split,
#                             min_samples_leaf, min_weight_leaf,
#                             max_depth, mgroup, mvar,
#                             min_impurity_decrease, min_impurity_split)

class CARTGVCriterionTest(unittest.TestCase):

    def _cinit_CARTGVClassificationCriterion_v2(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # y = train['Y']

        y = np.array([[0], [1], [0], [1], [1]])

        y = np.atleast_1d(y)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVClassificationCriterion(n_outputs, n_classes)

        self.assertIsNone(criterion.sample_weight)
        self.assertIsNone(criterion.samples)
        self.assertIsNone(criterion.starts)
        self.assertIsNone(criterion.ends)
        self.assertIsNone(criterion.impurity_childs)
        self.assertEqual(criterion.n_childs, 0)
        self.assertEqual(criterion.n_outputs, n_outputs)
        self.assertEqual(criterion.n_samples, 0)
        self.assertEqual(criterion.n_node_samples, 0)
        self.assertEqual(criterion.weighted_n_node_samples, 0.0)
        self.assertIsNone(criterion.weighted_n_childs)
        # self.assertIsNone(criterion.sum_childs) # Property a faire
        self.assertSequenceEqual(criterion.n_classes.tolist(), n_classes.tolist())
        self.assertEqual(criterion.sum_stride, max(n_classes))
        self.assertSequenceEqual(criterion.sum_total.tolist(), np.zeros(n_outputs*criterion.sum_stride).tolist())

    def _proxy_impurity_improvement_CARTGVClassificationCriterion_v2(self):
        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        # X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
        #                -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
        #                -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
        #                -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
        #                -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
        #                -0.305537695526707, -0.551540574269715],
        #               [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
        #                -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
        #                -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
        #                -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
        #                0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
        #                -2.09969534371281],
        #               [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
        #                0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
        #                0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
        #                -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
        #                -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
        #               [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
        #                1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
        #                0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
        #                -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
        #                0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
        #               [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
        #                0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
        #                -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
        #                -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
        #                -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
        #               ], dtype=np.float32)
        #
        # y = np.array([[0], [1], [0], [1], [1]])

        y = np.atleast_1d(y)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        sample_weight = None
        weighted_n_samples = X.shape[0]
        samples = np.arange(X.shape[0], dtype=np.intp)
        start = np.intp(0)
        end = np.intp(X.shape[0] - 1)
        criterion.test_init(y, sample_weight, weighted_n_samples, samples, start, end)
        criterion.test_reset()
        criterion.test_update()
        improvement = criterion.test_proxy_impurity_improvement()

        self.assertTrue(improvement <= 0)

    def _impurity_improvement_CARTGVClassificationCriterion_v2(self):
        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        # X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
        #                -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
        #                -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
        #                -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
        #                -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
        #                -0.305537695526707, -0.551540574269715],
        #               [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
        #                -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
        #                -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
        #                -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
        #                0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
        #                -2.09969534371281],
        #               [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
        #                0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
        #                0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
        #                -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
        #                -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
        #               [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
        #                1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
        #                0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
        #                -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
        #                0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
        #               [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
        #                0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
        #                -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
        #                -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
        #                -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
        #               ], dtype=np.float32)
        #
        # y = np.array([[0], [1], [0], [1], [1]])

        y = np.atleast_1d(y)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        sample_weight = None
        weighted_n_samples = X.shape[0]
        samples = np.arange(X.shape[0], dtype=np.intp)
        start = np.intp(0)
        end = np.intp(X.shape[0] - 1)
        criterion.test_init(y, sample_weight, weighted_n_samples, samples, start, end)
        criterion.test_reset()
        criterion.test_update()
        impurity_parent = criterion.test_node_impurity()
        improvement = criterion.test_impurity_improvement(impurity_parent,np.array(criterion.test_children_impurity()))
        print(improvement)
        # self.assertTrue(improvement >= 0)

    def _init_CARTGVClassificationCriterion_v2(self):
        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        y = np.atleast_1d(y)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVClassificationCriterion(n_outputs, n_classes)

        sample_weight = None
        weighted_n_samples = X.shape[0]
        samples = np.arange(X.shape[0], dtype=np.intp)
        start = np.intp(0)
        end = np.intp(X.shape[0])
        criterion.test_init(y, sample_weight, weighted_n_samples, samples, start, end)

        self.assertEqual(np.array(criterion.y).all(), y.all())
        self.assertEqual(criterion.sample_weight, sample_weight)
        # self.assertSequenceEqual(criterion.starts.tolist(), [start])
        # self.assertSequenceEqual(criterion.ends.tolist(), [end])
        self.assertEqual(criterion.n_node_samples, end - start)
        self.assertEqual(criterion.weighted_n_samples, weighted_n_samples)
        self.assertEqual(criterion.weighted_n_node_samples, np.sum(np.ones(X.shape[0])))

    def _reset_CARTGVClassificationCriterion_v2(self):
        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        y = np.atleast_1d(y)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVClassificationCriterion(n_outputs, n_classes)

        sample_weight = None
        weighted_n_samples = X.shape[0]
        samples = np.arange(X.shape[0], dtype=np.intp)
        start = np.intp(0)
        end = np.intp(X.shape[0] - 1)
        criterion.test_init(y, sample_weight, weighted_n_samples, samples, start, end)
        criterion.test_reset()

    def _update_CARTGVClassificationCriterion_v2(self):
        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        # X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
        #                -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
        #                -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
        #                -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
        #                -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
        #                -0.305537695526707, -0.551540574269715],
        #               [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
        #                -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
        #                -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
        #                -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
        #                0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
        #                -2.09969534371281],
        #               [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
        #                0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
        #                0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
        #                -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
        #                -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
        #               [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
        #                1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
        #                0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
        #                -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
        #                0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
        #               [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
        #                0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
        #                -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
        #                -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
        #                -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
        #               ], dtype=np.float32)
        #
        # y = np.array([[0], [1], [0], [1], [1]])

        y = np.atleast_1d(y)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVClassificationCriterion(n_outputs, n_classes)

        sample_weight = None
        weighted_n_samples = X.shape[0]
        samples = np.arange(X.shape[0], dtype=np.intp)
        start = np.intp(0)
        end = np.intp(X.shape[0] - 1)
        criterion.test_init(y, sample_weight, weighted_n_samples, samples, start, end)
        criterion.test_reset()
        criterion.test_update()

    def _node_value_CARTGVClassificationCriterion_v2(self):
        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        # X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
        #                -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
        #                -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
        #                -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
        #                -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
        #                -0.305537695526707, -0.551540574269715],
        #               [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
        #                -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
        #                -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
        #                -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
        #                0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
        #                -2.09969534371281],
        #               [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
        #                0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
        #                0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
        #                -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
        #                -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
        #               [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
        #                1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
        #                0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
        #                -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
        #                0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
        #               [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
        #                0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
        #                -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
        #                -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
        #                -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
        #               ], dtype=np.float32)
        #
        # y = np.array([[0], [1], [0], [1], [1]])

        y = np.atleast_1d(y)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVClassificationCriterion(n_outputs, n_classes)

        sample_weight = None
        weighted_n_samples = X.shape[0]
        samples = np.arange(X.shape[0], dtype=np.intp)
        start = np.intp(0)
        end = np.intp(X.shape[0] - 1)
        criterion.test_init(y, sample_weight, weighted_n_samples, samples, start, end)
        criterion.test_reset()
        criterion.test_node_value()

    def _node_impurity_CARTGVGini_v2(self):
        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        # X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
        #                -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
        #                -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
        #                -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
        #                -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
        #                -0.305537695526707, -0.551540574269715],
        #               [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
        #                -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
        #                -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
        #                -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
        #                0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
        #                -2.09969534371281],
        #               [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
        #                0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
        #                0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
        #                -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
        #                -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
        #               [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
        #                1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
        #                0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
        #                -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
        #                0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
        #               [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
        #                0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
        #                -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
        #                -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
        #                -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
        #               ], dtype=np.float32)
        #
        # y = np.array([[0], [1], [0], [1], [1]])

        y = np.atleast_1d(y)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        sample_weight = None
        weighted_n_samples = X.shape[0]
        samples = np.arange(X.shape[0], dtype=np.intp)
        start = np.intp(0)
        end = np.intp(X.shape[0] - 1)
        criterion.test_init(y, sample_weight, weighted_n_samples, samples, start, end)
        criterion.test_reset()
        criterion.test_update()
        impurity = criterion.test_node_impurity()

        self.assertTrue(impurity >= 0)

    def _children_impurity_CARTGVGini_v2(self):
        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        # X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
        #                -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
        #                -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
        #                -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
        #                -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
        #                -0.305537695526707, -0.551540574269715],
        #               [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
        #                -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
        #                -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
        #                -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
        #                0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
        #                -2.09969534371281],
        #               [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
        #                0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
        #                0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
        #                -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
        #                -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
        #               [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
        #                1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
        #                0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
        #                -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
        #                0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
        #               [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
        #                0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
        #                -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
        #                -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
        #                -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
        #               ], dtype=np.float32)
        #
        # y = np.array([[0], [1], [0], [1], [1]])

        y = np.atleast_1d(y)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        sample_weight = None
        weighted_n_samples = X.shape[0]
        samples = np.arange(X.shape[0], dtype=np.intp)
        start = np.intp(0)
        end = np.intp(X.shape[0] - 1)
        criterion.test_init(y, sample_weight, weighted_n_samples, samples, start, end)
        criterion.test_reset()
        criterion.test_update()
        criterion.test_children_impurity()


class CARTGVSplitterTest(unittest.TestCase):

    def _cinit_splitter_v2(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = CARTGVSplitter(criterion, max_grouped_features, len(groups),
                                     min_samples_leaf, min_weight_leaf,
                                     random_state, max_depth, min_impurity_decrease, min_impurity_split, mvar,
                                      mgroup)

        self.assertEqual(type(splitter.criterion),type(criterion))
        self.assertIsNone(splitter.samples)
        self.assertEqual(splitter.n_samples,0)
        self.assertIsNone(splitter.features)
        self.assertEqual(splitter.n_features,0)
        self.assertIsNone(splitter.sample_weight)
        self.assertEqual(splitter.max_grouped_features,max_grouped_features)
        self.assertEqual(splitter.min_weight_leaf,min_weight_leaf)
        self.assertEqual(splitter.min_samples_leaf,min_samples_leaf)
        self.assertEqual(splitter.random_state,random_state)
        self.assertEqual(np.array(splitter.groups).all(),np.empty((len(groups), max_grouped_features), dtype=int).all())
        self.assertEqual(splitter.n_groups,len(groups))
        self.assertEqual(np.array(splitter.len_groups).all(),np.empty((len(groups)), dtype=int).all())
        self.assertIsNone(splitter.splitting_tree_builder)
        self.assertIsNone(splitter.splitting_tree)

    def _init_splitter_v2(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = np.random.RandomState(2547)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = CARTGVSplitter(criterion, max_grouped_features, len(groups),
                                     min_samples_leaf, min_weight_leaf,
                                     random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        res = splitter.test_init(X, y, sample_weight, groups)

        self.assertEqual(res, 0)
        # self.assertTrue(np.array(splitter.samples).all() == np.arange(X.shape[0]).all())
        self.assertEqual(splitter.n_samples,X.shape[0])
        self.assertEqual(splitter.weighted_n_samples,X.shape[0])
        # self.assertTrue((splitter.features).all() == np.arange(X.shape[1]).all())
        self.assertEqual(splitter.n_features,X.shape[1]) # Est ce que c'est vraiment cela que l'on veut ???
        # self.assertTrue(y.all() == np.asarray(splitter.y).all())
        # if sample_weight != None:
            # self.assertTrue(np.asarray(splitter.sample_weight).all() == sample_weight.all())
        # self.assertTrue(np.array(splitter.groups).all() == groups.all())
        self.assertEqual(splitter.n_groups, len(groups))
        # self.assertTrue(np.array(splitter.len_groups).all() == np.array([len(group) for group in groups]).all())

    def _node_reset_splitter_v2(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = CARTGVSplitter(criterion, max_grouped_features, len(groups),
                                     min_samples_leaf, min_weight_leaf,
                                     random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        res = splitter.test_node_reset(start, end, weighted_n_node_samples)

        self.assertEqual(res,0)
        self.assertEqual(splitter.start,start)
        self.assertEqual(splitter.end,end)

    def _node_value_splitter_v2(self):

        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]

        groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        # X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
        #                -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
        #                -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
        #                -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
        #                -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
        #                -0.305537695526707, -0.551540574269715],
        #               [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
        #                -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
        #                -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
        #                -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
        #                0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
        #                -2.09969534371281],
        #               [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
        #                0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
        #                0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
        #                -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
        #                -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
        #               [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
        #                1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
        #                0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
        #                -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
        #                0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
        #               [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
        #                0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
        #                -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
        #                -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
        #                -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
        #               ], dtype=np.float32)
        #
        # y = np.array([[0], [1], [0], [1], [1]])
        #
        # groups = np.array(
        #     [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = CARTGVSplitter(criterion, max_grouped_features, len(groups),
                                     min_samples_leaf, min_weight_leaf,
                                     random_state, max_depth, min_impurity_decrease, min_impurity_split, mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)

        test = [0,1,2,3,4]
        node_value = splitter.test_node_value(test[2])
        self.assertTrue(node_value >= 0)

    def _node_impurity_splitter_v2(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5


        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = CARTGVSplitter(criterion, max_grouped_features, len(groups),
                                     min_samples_leaf, min_weight_leaf,
                                     random_state,max_depth, min_impurity_decrease, min_impurity_split, mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)

        node_impurity = splitter.test_node_impurity()
        self.assertTrue(node_impurity >= 0)

    def _init_BaseDenseSplitter_v2(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = np.random.RandomState(2547)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BaseDenseCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                     min_samples_leaf, min_weight_leaf,
                                     random_state, max_depth, min_impurity_decrease, min_impurity_split, mvar,
                                      mgroup)

        sample_weight = None
        res = splitter.test_init(X, y, sample_weight, groups) #X.to_numpy(dtype=np.float32)

        self.assertEqual(res, 0)
        # self.assertTrue(np.array(splitter.samples).all() == np.arange(X.shape[0]).all())
        self.assertEqual(splitter.n_samples, X.shape[0])
        self.assertEqual(splitter.weighted_n_samples, X.shape[0])
        # self.assertTrue((splitter.features).all() == np.arange(X.shape[1]).all())
        self.assertEqual(splitter.n_features, X.shape[1])  # Est ce que c'est vraiment cela que l'on veut ???
        # self.assertTrue(y.all() == np.asarray(splitter.y).all())
        if sample_weight != None:
            self.assertTrue(np.asarray(splitter.sample_weight).all() == sample_weight.all())
        # self.assertTrue(np.array(splitter.groups).all() == groups.all())
        self.assertEqual(splitter.n_groups, len(groups))
        # self.assertTrue(np.array(splitter.len_groups).all() == np.array([len(group) for group in groups]).all())
        # self.assertTrue(X.all().all() == np.array(splitter.X).all().all())

    def _group_sample_BestCARTGVSplitter_v2(self):
        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                     min_samples_leaf, min_weight_leaf,
                                     random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups) #X.to_numpy(dtype=np.float32)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)

        Xf = splitter.test_group_sample(groups[0], len(groups[0]), start, end)

        # self.assertEqual(Xf.all(), np.array(X)[:,groups[0][0]:len(groups[0])].all())

    def _reset_scikit_learn_instances_BestCARTGVSplitter_v2(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                         min_samples_leaf, min_weight_leaf,
                                         random_state, max_depth, min_impurity_decrease, min_impurity_split, mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups) #X.to_numpy(dtype=np.float32)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)
        splitter.test_reset_scikit_learn_instances(y, len(groups[0]))

        tree = Tree(len(groups[0]), n_classes, n_outputs)

        self.assertEqual(type(splitter.splitting_tree), type(tree))
        self.assertEqual(splitter.splitting_tree.n_features, tree.n_features)
        self.assertEqual(splitter.splitting_tree.n_outputs, tree.n_outputs)
        # self.assertEqual(np.array(splitter.splitting_tree.n_classes).all(), np.array(tree.n_classes).all())
        self.assertEqual(splitter.splitting_tree.max_n_classes, tree.max_n_classes)
        self.assertEqual(splitter.splitting_tree.max_depth, tree.max_depth)
        self.assertEqual(splitter.splitting_tree.node_count, tree.node_count)
        self.assertEqual(splitter.splitting_tree.capacity, tree.capacity)
        # self.assertEqual(splitter.splitting_tree.value.all(), tree.value.all())

        max_features = len(groups[0])
        min_samples_leaf = 1
        min_samples_split = 2
        min_weight_leaf = 0.0
        max_depth = 3
        min_impurity_decrease = 0.
        min_impurity_split = 0.
        random_state = np.random.RandomState(2547)

        criterion = Gini(n_outputs, n_classes)

        spltr = BestSplitter(criterion, max_features, min_samples_leaf, min_weight_leaf, random_state)

        depthFirstTreeBuilder = DepthFirstTreeBuilder(spltr, min_samples_split, min_samples_leaf, min_weight_leaf,
                                                      max_depth, min_impurity_decrease, min_impurity_split)

        ### CAN'T TEST BECAUSE THEY AREN'T PROPERTIES IN SCIKIT-LEARN ###

        self.assertEqual(type(splitter.splitting_tree_builder),type(depthFirstTreeBuilder))
        # self.assertEqual(type(splitter.splitting_tree_builder.splitter),type(depthFirstTreeBuilder.splitter))
        # self.assertEqual(splitter.splitting_tree_builder.min_samples_split, min_samples_split)
        # self.assertEqual(splitter.splitting_tree_builder.min_samples_leaf,min_samples_leaf)
        # self.assertEqual(splitter.splitting_tree_builder.min_weight_leaf,min_weight_leaf)
        # self.assertEqual(splitter.splitting_tree_builder.max_depth,max_depth)
        # self.assertEqual(splitter.splitting_tree_builder.min_impurity_decrease, min_impurity_decrease)
        # self.assertEqual(splitter.splitting_tree_builder.min_impurity_split, min_impurity_split)

    def _n_reset_scikit_learn_instances_BestCARTGVSplitter_v2(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = np.random.RandomState(2547)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                         min_samples_leaf, min_weight_leaf,
                                         random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups) #X.to_numpy(dtype=np.float32)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)

        for i in range(5):

            splitter.test_reset_scikit_learn_instances(y, len(groups[0]))

            tree = Tree(len(groups[0]), n_classes, n_outputs)

            self.assertEqual(type(splitter.splitting_tree), type(tree))
            self.assertEqual(splitter.splitting_tree.n_features, tree.n_features)
            self.assertEqual(splitter.splitting_tree.n_outputs, tree.n_outputs)
            # self.assertEqual(np.array(splitter.splitting_tree.n_classes).all(), np.array(tree.n_classes).all())
            self.assertEqual(splitter.splitting_tree.max_n_classes, tree.max_n_classes)
            self.assertEqual(splitter.splitting_tree.max_depth, tree.max_depth)
            self.assertEqual(splitter.splitting_tree.node_count, tree.node_count)
            self.assertEqual(splitter.splitting_tree.capacity, tree.capacity)
            # self.assertEqual(splitter.splitting_tree.value.all(), tree.value.all())

            max_features = len(groups[0])
            min_samples_leaf = 1
            min_samples_split = 2
            min_weight_leaf = 0.0
            max_depth = 3
            min_impurity_decrease = 0.
            min_impurity_split = 0.
            random_state = np.random.RandomState(2547)

            criterion = Gini(n_outputs, n_classes)

            spltr = BestSplitter(criterion, max_features, min_samples_leaf, min_weight_leaf, random_state)

            depthFirstTreeBuilder = DepthFirstTreeBuilder(spltr, min_samples_split, min_samples_leaf, min_weight_leaf,
                                                          max_depth, min_impurity_decrease, min_impurity_split)

            ### CAN'T TEST BECAUSE THEY AREN'T PROPERTIES IN SCIKIT-LEARN ###

            self.assertEqual(type(splitter.splitting_tree_builder),type(depthFirstTreeBuilder))
            # self.assertEqual(type(splitter.splitting_tree_builder.splitter),type(depthFirstTreeBuilder.splitter))
            # self.assertEqual(splitter.splitting_tree_builder.min_samples_split, min_samples_split)
            # self.assertEqual(splitter.splitting_tree_builder.min_samples_leaf,min_samples_leaf)
            # self.assertEqual(splitter.splitting_tree_builder.min_weight_leaf,min_weight_leaf)
            # self.assertEqual(splitter.splitting_tree_builder.max_depth,max_depth)
            # self.assertEqual(splitter.splitting_tree_builder.min_impurity_decrease, min_impurity_decrease)
            # self.assertEqual(splitter.splitting_tree_builder.min_impurity_split, min_impurity_split)

    def _splitting_tree_construction_BestCARTGVSplitter_v2(self):
        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                         min_samples_leaf, min_weight_leaf,
                                         random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups) #X.to_numpy(dtype=np.float32)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)

        Xf = splitter.test_group_sample(groups[0], len(groups[0]), start, end)
        splitter.test_reset_scikit_learn_instances(y, len(groups[0]))
        splitter.test_splitting_tree_construction(Xf,y)

        tree = Tree(len(groups[0]), n_classes, n_outputs)

        max_features = len(groups[0])
        min_samples_leaf = 1
        min_samples_split = 2
        min_weight_leaf = 0.0
        max_depth = 3
        min_impurity_decrease = 0.
        min_impurity_split = 0.
        random_state = np.random.RandomState(2547)

        criterion = Gini(n_outputs, n_classes)

        spltr = BestSplitter(criterion, max_features, min_samples_leaf, min_weight_leaf, random_state)

        depthFirstTreeBuilder = DepthFirstTreeBuilder(spltr, min_samples_split, min_samples_leaf, min_weight_leaf,
                                                      max_depth, min_impurity_decrease, min_impurity_split)

        depthFirstTreeBuilder.build(tree,Xf,y)

        self.assertEqual(type(splitter.splitting_tree), type(tree))
        self.assertEqual(splitter.splitting_tree.n_features, tree.n_features)
        self.assertEqual(splitter.splitting_tree.n_outputs, tree.n_outputs)
        # self.assertEqual(np.array(splitter.splitting_tree.n_classes).all(), np.array(tree.n_classes).all())
        self.assertEqual(splitter.splitting_tree.max_n_classes, tree.max_n_classes)
        self.assertEqual(splitter.splitting_tree.max_depth, tree.max_depth)
        self.assertEqual(splitter.splitting_tree.node_count, tree.node_count)
        self.assertEqual(splitter.splitting_tree.capacity, tree.capacity)
        # self.assertEqual(splitter.splitting_tree.value.all(), tree.value.all())

    def _n_splitting_tree_construction_BestCARTGVSplitter_v2(self):
        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                         min_samples_leaf, min_weight_leaf,
                                         random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups) #X.to_numpy(dtype=np.float32)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)

        for i in range(5):
            Xf = splitter.test_group_sample(groups[0], len(groups[0]), start, end)
            splitter.test_reset_scikit_learn_instances(y, len(groups[0]))
            splitter.test_splitting_tree_construction(Xf,y)

            tree = Tree(len(groups[0]), n_classes, n_outputs)

            max_features = len(groups[0])
            min_samples_leaf = 1
            min_samples_split = 2
            min_weight_leaf = 0.0
            max_depth = 3
            min_impurity_decrease = 0.
            min_impurity_split = 0.
            random_state = np.random.RandomState(2547)

            criterion = Gini(n_outputs, n_classes)

            spltr = BestSplitter(criterion, max_features, min_samples_leaf, min_weight_leaf, random_state)

            depthFirstTreeBuilder = DepthFirstTreeBuilder(spltr, min_samples_split, min_samples_leaf, min_weight_leaf,
                                                          max_depth, min_impurity_decrease, min_impurity_split)

            depthFirstTreeBuilder.build(tree,Xf,y)

            self.assertEqual(type(splitter.splitting_tree), type(tree))
            self.assertEqual(splitter.splitting_tree.n_features, tree.n_features)
            self.assertEqual(splitter.splitting_tree.n_outputs, tree.n_outputs)
            # self.assertEqual(np.array(splitter.splitting_tree.n_classes).all(), np.array(tree.n_classes).all())
            self.assertEqual(splitter.splitting_tree.max_n_classes, tree.max_n_classes)
            self.assertEqual(splitter.splitting_tree.max_depth, tree.max_depth)
            self.assertEqual(splitter.splitting_tree.node_count, tree.node_count)
            self.assertEqual(splitter.splitting_tree.capacity, tree.capacity)
            # self.assertEqual(splitter.splitting_tree.value.all(), tree.value.all())

    def _get_splitting_tree_leaves_BestCARTGVSplitter_v2(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                         min_samples_leaf, min_weight_leaf,
                                         random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups) #X.to_numpy(dtype=np.float32)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)

        Xf = splitter.test_group_sample(groups[0], len(groups[0]), start, end)
        splitter.test_reset_scikit_learn_instances(y, len(groups[0]))
        splitter.test_splitting_tree_construction(Xf, y)
        splitter.test_get_splitting_tree_leaves()

        max_depth = 3
        random_state = np.random.RandomState(2547)

        # clf = DecisionTreeClassifier(max_depth=max_depth, random_state=random_state, max_features=len(groups[0]),
        #                              max_leaf_nodes=X.shape[0])
        # tree = clf.fit(X.iloc[:, groups[0]], y)
        # fig, ax = plt.subplots(1, 2, figsize=(16, 9))
        # plot_tree(tree, ax=ax[0])

        # clf.tree_ = splitter.splitting_tree
        # plot_tree(tree, ax=ax[1])
        # plt.show()

    def _get_splitting_tree_leaves_samples_and_pos_BestCARTGVSplitter_v2(self):

        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]

        groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        # X = np.array([[-0.962564615251298,-0.0818379297761482,-0.257129359665299,-1.20057124658537,-1.67321037673198,-0.850857878613548,-1.12636943482486,0.264691871869928,0.823490524418768,-0.289267055667413,0.375612134943435,0.689033636785644,-0.0755870733096488,-0.253686040025422,-0.767686310824219,-0.47706960213735,0.619681515116366,-0.718706304417254,-0.625998377401577,0.595352830214443,-0.826055466109155,0.841770278364141,0.525998122722698,-0.305537695526707,-0.551540574269715],
        #               [-0.0170226173861495,-0.575187308059669,-0.0550716676440694,-0.596082039595892,-0.153767849941737,-0.152659395126548,0.103284766044348,0.945962098961183,0.11395628892521,-1.0314335555107,-0.24180964927081,-0.225116148572662,1.75090409682049,0.276212128428595,-0.226985192750251,-0.688321496802469,0.721869146316049,-0.0427129520106458,1.71093452174155,0.440414655312213,-0.219061974136534,0.370516601227188,-0.579953711046926,-2.4756697600574,-2.09969534371281],
        #               [0.859846852829686,-0.196768997920202,-0.665097766775893,1.49845086392502,0.712519776986412,0.63382801135412,0.338132006534241,-1.17912479597116,0.337710921150664,-0.404533729530606,0.984579714687047,-1.16236566382262,-0.786198019602607,-0.753822112046281,-0.811264249392465,-0.594151853267325,-0.322916128201519,-1.2934117213506,0.531732629482942,-1.6136606736686,-1.27887838930757,0.678437793765498,-1.19080597429513,1.11533360829611,-0.340409112584892],
        #               [-1.46244895844162,0.508777691805245,-0.42599215315616,-0.570342024814983,-1.13004768682085,1.12406519881936,0.251809560422478,-2.06632443310484,-1.23862336004496,1.6527814698557,0.336827946772908,-0.233201791535758,0.590072797080428,1.7453946472635,1.02016573606479,-0.813457453508146,-0.0745696971758758,2.89463767013771,0.158622453385045,-1.70880561223817,0.132671092412739,-0.479946273307748,0.11444508132886,1.40287375218729,-0.344499428025485],
        #               [-0.383681631574503,1.19713456197882,-0.302078922002226,-0.544313316070517,1.11301409047452,0.0643648126207925,0.623795834834719,0.288528481567621,-0.618352387217919,-0.180420032776369,-0.974252399377197,-0.78154085269986,0.673878430962106,-0.14493184535421,-1.58840476437875,-0.89040398934659,-0.464336091106138,-0.804400496705168,0.542582301058101,-0.213424538311193,-0.925675256270349,0.306707969484467,0.378645850648093,0.220134583700443,-0.0925601673405935]
        #               ],dtype=np.float32)
        #
        # y = np.array([[0],[1],[0],[1],[1]])
        #
        # groups = np.array([[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                         min_samples_leaf, min_weight_leaf,
                                         random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X.to_numpy(dtype=np.float32), y, sample_weight, groups) #X.to_numpy(dtype=np.float32)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)

        Xf = splitter.test_group_sample(groups[0], len(groups[0]), start, end)
        splitter.test_reset_scikit_learn_instances(y, len(groups[0]))
        splitter.test_splitting_tree_construction(Xf, y)
        splitter.test_get_splitting_tree_leaves_samples_and_pos()

    def _switch_best_splitting_tree_BestCARTGVSplitter_v2(self):

        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]

        groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        # X = np.array([[-0.962564615251298,-0.0818379297761482,-0.257129359665299,-1.20057124658537,-1.67321037673198,-0.850857878613548,-1.12636943482486,0.264691871869928,0.823490524418768,-0.289267055667413,0.375612134943435,0.689033636785644,-0.0755870733096488,-0.253686040025422,-0.767686310824219,-0.47706960213735,0.619681515116366,-0.718706304417254,-0.625998377401577,0.595352830214443,-0.826055466109155,0.841770278364141,0.525998122722698,-0.305537695526707,-0.551540574269715],
        #               [-0.0170226173861495,-0.575187308059669,-0.0550716676440694,-0.596082039595892,-0.153767849941737,-0.152659395126548,0.103284766044348,0.945962098961183,0.11395628892521,-1.0314335555107,-0.24180964927081,-0.225116148572662,1.75090409682049,0.276212128428595,-0.226985192750251,-0.688321496802469,0.721869146316049,-0.0427129520106458,1.71093452174155,0.440414655312213,-0.219061974136534,0.370516601227188,-0.579953711046926,-2.4756697600574,-2.09969534371281],
        #               [0.859846852829686,-0.196768997920202,-0.665097766775893,1.49845086392502,0.712519776986412,0.63382801135412,0.338132006534241,-1.17912479597116,0.337710921150664,-0.404533729530606,0.984579714687047,-1.16236566382262,-0.786198019602607,-0.753822112046281,-0.811264249392465,-0.594151853267325,-0.322916128201519,-1.2934117213506,0.531732629482942,-1.6136606736686,-1.27887838930757,0.678437793765498,-1.19080597429513,1.11533360829611,-0.340409112584892],
        #               [-1.46244895844162,0.508777691805245,-0.42599215315616,-0.570342024814983,-1.13004768682085,1.12406519881936,0.251809560422478,-2.06632443310484,-1.23862336004496,1.6527814698557,0.336827946772908,-0.233201791535758,0.590072797080428,1.7453946472635,1.02016573606479,-0.813457453508146,-0.0745696971758758,2.89463767013771,0.158622453385045,-1.70880561223817,0.132671092412739,-0.479946273307748,0.11444508132886,1.40287375218729,-0.344499428025485],
        #               [-0.383681631574503,1.19713456197882,-0.302078922002226,-0.544313316070517,1.11301409047452,0.0643648126207925,0.623795834834719,0.288528481567621,-0.618352387217919,-0.180420032776369,-0.974252399377197,-0.78154085269986,0.673878430962106,-0.14493184535421,-1.58840476437875,-0.89040398934659,-0.464336091106138,-0.804400496705168,0.542582301058101,-0.213424538311193,-0.925675256270349,0.306707969484467,0.378645850648093,0.220134583700443,-0.0925601673405935]
        #               ],dtype=np.float32)
        #
        # y = np.array([[0],[1],[0],[1],[1]])
        #
        # groups = np.array([[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        random_state = check_random_state(2457)
        mvar = 5
        mgroup = 5

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                         min_samples_leaf, min_weight_leaf,
                                         random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X.to_numpy(dtype=np.float32), y, sample_weight, groups) #X.to_numpy(dtype=np.float32)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)

        Xf = splitter.test_group_sample(groups[0], len(groups[0]), start, end)
        splitter.test_reset_scikit_learn_instances(y, len(groups[0]))
        splitter.test_splitting_tree_construction(Xf, y)
        splitter.test_switch_best_splitting_tree()

    def _node_split_BestCARTGVSplitter_v2(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298,-0.0818379297761482,-0.257129359665299,-1.20057124658537,-1.67321037673198,-0.850857878613548,-1.12636943482486,0.264691871869928,0.823490524418768,-0.289267055667413,0.375612134943435,0.689033636785644,-0.0755870733096488,-0.253686040025422,-0.767686310824219,-0.47706960213735,0.619681515116366,-0.718706304417254,-0.625998377401577,0.595352830214443,-0.826055466109155,0.841770278364141,0.525998122722698,-0.305537695526707,-0.551540574269715],
                      [-0.0170226173861495,-0.575187308059669,-0.0550716676440694,-0.596082039595892,-0.153767849941737,-0.152659395126548,0.103284766044348,0.945962098961183,0.11395628892521,-1.0314335555107,-0.24180964927081,-0.225116148572662,1.75090409682049,0.276212128428595,-0.226985192750251,-0.688321496802469,0.721869146316049,-0.0427129520106458,1.71093452174155,0.440414655312213,-0.219061974136534,0.370516601227188,-0.579953711046926,-2.4756697600574,-2.09969534371281],
                      [0.859846852829686,-0.196768997920202,-0.665097766775893,1.49845086392502,0.712519776986412,0.63382801135412,0.338132006534241,-1.17912479597116,0.337710921150664,-0.404533729530606,0.984579714687047,-1.16236566382262,-0.786198019602607,-0.753822112046281,-0.811264249392465,-0.594151853267325,-0.322916128201519,-1.2934117213506,0.531732629482942,-1.6136606736686,-1.27887838930757,0.678437793765498,-1.19080597429513,1.11533360829611,-0.340409112584892],
                      [-1.46244895844162,0.508777691805245,-0.42599215315616,-0.570342024814983,-1.13004768682085,1.12406519881936,0.251809560422478,-2.06632443310484,-1.23862336004496,1.6527814698557,0.336827946772908,-0.233201791535758,0.590072797080428,1.7453946472635,1.02016573606479,-0.813457453508146,-0.0745696971758758,2.89463767013771,0.158622453385045,-1.70880561223817,0.132671092412739,-0.479946273307748,0.11444508132886,1.40287375218729,-0.344499428025485],
                      [-0.383681631574503,1.19713456197882,-0.302078922002226,-0.544313316070517,1.11301409047452,0.0643648126207925,0.623795834834719,0.288528481567621,-0.618352387217919,-0.180420032776369,-0.974252399377197,-0.78154085269986,0.673878430962106,-0.14493184535421,-1.58840476437875,-0.89040398934659,-0.464336091106138,-0.804400496705168,0.542582301058101,-0.213424538311193,-0.925675256270349,0.306707969484467,0.378645850648093,0.220134583700443,-0.0925601673405935]
                      ],dtype=np.float32)

        y = np.array([[0],[1],[0],[1],[1]])

        groups = np.array([[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        mvar = 5
        mgroup = 5
        random_state = check_random_state(2457)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                         min_samples_leaf, min_weight_leaf,
                                         random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups)  # X.to_numpy(dtype=np.float32)

        start = 0
        end = n_samples
        weighted_n_node_samples = 0
        splitter.test_node_reset(start, end, weighted_n_node_samples)

        splitter.test_node_split()

class CARTGVTreeTest(unittest.TestCase):

    def _cinit_CARTGVTree(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298,-0.0818379297761482,-0.257129359665299,-1.20057124658537,-1.67321037673198,-0.850857878613548,-1.12636943482486,0.264691871869928,0.823490524418768,-0.289267055667413,0.375612134943435,0.689033636785644,-0.0755870733096488,-0.253686040025422,-0.767686310824219,-0.47706960213735,0.619681515116366,-0.718706304417254,-0.625998377401577,0.595352830214443,-0.826055466109155,0.841770278364141,0.525998122722698,-0.305537695526707,-0.551540574269715],
                      [-0.0170226173861495,-0.575187308059669,-0.0550716676440694,-0.596082039595892,-0.153767849941737,-0.152659395126548,0.103284766044348,0.945962098961183,0.11395628892521,-1.0314335555107,-0.24180964927081,-0.225116148572662,1.75090409682049,0.276212128428595,-0.226985192750251,-0.688321496802469,0.721869146316049,-0.0427129520106458,1.71093452174155,0.440414655312213,-0.219061974136534,0.370516601227188,-0.579953711046926,-2.4756697600574,-2.09969534371281],
                      [0.859846852829686,-0.196768997920202,-0.665097766775893,1.49845086392502,0.712519776986412,0.63382801135412,0.338132006534241,-1.17912479597116,0.337710921150664,-0.404533729530606,0.984579714687047,-1.16236566382262,-0.786198019602607,-0.753822112046281,-0.811264249392465,-0.594151853267325,-0.322916128201519,-1.2934117213506,0.531732629482942,-1.6136606736686,-1.27887838930757,0.678437793765498,-1.19080597429513,1.11533360829611,-0.340409112584892],
                      [-1.46244895844162,0.508777691805245,-0.42599215315616,-0.570342024814983,-1.13004768682085,1.12406519881936,0.251809560422478,-2.06632443310484,-1.23862336004496,1.6527814698557,0.336827946772908,-0.233201791535758,0.590072797080428,1.7453946472635,1.02016573606479,-0.813457453508146,-0.0745696971758758,2.89463767013771,0.158622453385045,-1.70880561223817,0.132671092412739,-0.479946273307748,0.11444508132886,1.40287375218729,-0.344499428025485],
                      [-0.383681631574503,1.19713456197882,-0.302078922002226,-0.544313316070517,1.11301409047452,0.0643648126207925,0.623795834834719,0.288528481567621,-0.618352387217919,-0.180420032776369,-0.974252399377197,-0.78154085269986,0.673878430962106,-0.14493184535421,-1.58840476437875,-0.89040398934659,-0.464336091106138,-0.804400496705168,0.542582301058101,-0.213424538311193,-0.925675256270349,0.306707969484467,0.378645850648093,0.220134583700443,-0.0925601673405935]
                      ],dtype=np.float32)

        y = np.array([[0],[1],[0],[1],[1]])

        groups = np.array([[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        random_state = check_random_state(2457)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        cartgvtree = CARTGVTree(max_grouped_features,n_classes,n_outputs)

        self.assertEqual(cartgvtree.n_grouped_features,max_grouped_features)
        self.assertEqual(cartgvtree.n_outputs, n_outputs)
        self.assertSequenceEqual(cartgvtree.n_classes,n_classes)
        self.assertEqual(cartgvtree.max_n_classes,np.max(n_classes))
        self.assertEqual(cartgvtree.value_stride, n_outputs*np.max(n_classes))
        self.assertEqual(cartgvtree.max_depth,0)
        self.assertEqual(cartgvtree.node_count,0)
        self.assertEqual(cartgvtree.capacity, 0)
        self.assertIsNone(cartgvtree.value)
        self.assertIsNone(cartgvtree.nodes)

    def _resize_CARTGVTree(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        random_state = check_random_state(2457)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        cartgvtree = CARTGVTree(max_grouped_features, n_classes, n_outputs)

        capacity = 2047

        cartgvtree.test_resize_CARTGVTree(capacity)

        self.assertEqual(cartgvtree.node_count,0)
        self.assertEqual(cartgvtree.capacity,capacity)

    def _add_node(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_weight_leaf = 0
        max_depth = 3
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        mvar = 5
        mgroup = 5
        random_state = check_random_state(2457)

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=np.float64)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                      min_samples_leaf, min_weight_leaf,
                                      random_state, max_depth, min_impurity_decrease, min_impurity_split,mvar,
                                      mgroup)

        sample_weight = None
        splitter.test_init(X, y, sample_weight, groups)  # X.to_numpy(dtype=np.float32)

        start = 0
        end = n_samples

        cartgvtree = CARTGVTree(max_grouped_features, n_classes, n_outputs)

        cartgvtree.test_add_node(splitter, start, end)

class CARTGVTreeBuilderTest(unittest.TestCase):

    def _cinit_treebuilder(self):

        # df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)
        #
        # train = df.loc[df['Type'] == 'train']
        #
        # X = train.iloc[:, 2:]
        #
        # y = train['Y']
        #
        # g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        # g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        # g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        # g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        # g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]
        #
        # groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
                       -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
                       -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
                       -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
                       -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
                       -0.305537695526707, -0.551540574269715],
                      [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
                       -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
                       -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
                       -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
                       0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
                       -2.09969534371281],
                      [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
                       0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
                       0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
                       -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
                       -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
                      [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
                       1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
                       0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
                       -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
                       0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
                      [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
                       0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
                       -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
                       -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
                       -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
                      ], dtype=np.float32)

        y = np.array([[0], [1], [0], [1], [1]])

        groups = np.array(
            [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        n_grouped_features = 2
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_samples_split = 2
        min_weight_leaf = 0
        random_state = check_random_state(0)
        max_depth = 3
        mgroup = 1
        mvar = 10
        min_impurity_decrease = 0.1
        min_impurity_split = 0.0

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=int)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                  min_samples_leaf, min_weight_leaf,
                                  random_state, max_depth, min_impurity_decrease, min_impurity_split,
                                mvar,
                                mgroup
                                )

        tree = CARTGVTree(n_grouped_features, n_classes, n_outputs)

        builder = CARTGVTreeBuilder(splitter, min_samples_split,
                                    min_samples_leaf, min_weight_leaf,
                                    max_depth, mgroup, mvar,
                                    min_impurity_decrease, min_impurity_split)

        self.assertEqual(type(builder.splitter),type(splitter))
        self.assertEqual(builder.min_samples_split,min_samples_split)
        self.assertEqual(builder.min_samples_leaf, min_samples_leaf)
        self.assertEqual(builder.min_weight_leaf,min_weight_leaf)
        self.assertEqual(builder.max_depth,max_depth)
        self.assertEqual(builder.mgroup,mgroup)
        self.assertEqual(builder.mvar, mvar)
        self.assertEqual(builder.min_impurity_decrease,min_impurity_decrease)
        self.assertEqual(builder.min_impurity_split, min_impurity_split)

    def _build_treebuilder(self):

        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]

        groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        # X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
        #                -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
        #                -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
        #                -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
        #                -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
        #                -0.305537695526707, -0.551540574269715],
        #               [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
        #                -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
        #                -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
        #                -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
        #                0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
        #                -2.09969534371281],
        #               [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
        #                0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
        #                0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
        #                -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
        #                -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
        #               [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
        #                1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
        #                0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
        #                -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
        #                0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
        #               [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
        #                0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
        #                -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
        #                -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
        #                -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
        #               ], dtype=np.float32)
        #
        # y = np.array([[0], [1], [0], [1], [1]])
        #
        # groups = np.array(
        #     [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        n_grouped_features = 5
        y = np.atleast_1d(y)
        max_grouped_features = 5 #max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_samples_split = 2
        min_weight_leaf = 0
        random_state = check_random_state(2547)
        max_depth = 2
        max_depth_splitting_tree = 3
        mgroup = 5
        mvar = 5
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        min_impurity_decrease_splitting_tree = 0.1
        min_impurity_split_spltting_tree= 0.1

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=int)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)
        times = np.ndarray(1)
        startLoop = time.time()
        for i in range(1):
            start = time.time()
            criterion = CARTGVGini(n_outputs, n_classes)

            splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                      min_samples_leaf, min_weight_leaf,
                                      random_state, max_depth_splitting_tree,
                                      min_impurity_decrease_splitting_tree,
                                      min_impurity_split_spltting_tree,
                                      mvar,
                                      mgroup)

            tree = CARTGVTree(n_grouped_features, n_classes, n_outputs)

            builder = CARTGVTreeBuilder(splitter, min_samples_split,
                                        min_samples_leaf, min_weight_leaf,
                                        max_depth, mgroup, mvar,
                                        min_impurity_decrease, min_impurity_split)

            # builder.build(tree, X.to_numpy(dtype=np.float32), y, groups, None) #X.to_numpy(dtype=np.float32)
            print("####################### Tree Builder tree #####################")
            builder.test_build(tree, X.to_numpy(dtype=np.float32), y, groups) #X.to_numpy(dtype=np.float32)
            end = time.time()
            times[i] = end-start
        print("Mean Time for 1 tree : " + str(np.mean(times)))
        endLoop = time.time()
        print("Time Loop : " + str(endLoop-startLoop))
        clf = DecisionTreeClassifier(max_depth=max_depth, random_state=random_state, max_features=len(groups[0]),
                                     max_leaf_nodes=X.shape[0])

        for i in range(tree.node_count):
            if (tree.nodes_splitting_trees[i] != None):
                clf.tree_ = tree.nodes_splitting_trees[i]
                fig, ax = plt.subplots(1, figsize=(16, 9))
                plot_tree(clf)
                plt.show()

        # print(tree.nodes_childs)
        print(tree.nodes_parent)
        print(tree.nodes_impurities)
        print(tree.nodes_n_node_samples)
        print(tree.nodes_weighted_n_node_samples)
        print(tree.nodes_group)
        print(tree.nodes_n_childs)

        print(tree.node_count)
        print(tree.max_depth)
        print(tree.n_grouped_features)
        print(tree.n_outputs)
        print(tree.n_classes)
        print(tree.max_n_classes)
        print(tree.value_stride)
        print(tree.capacity)
        print(tree.value) #Not sure what it represent
        # print(tree.nodes) #TODO find a way to make it possible

class Cython_R_Comparison(unittest.TestCase):

    def _comparison(self):

        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]

        groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        # X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
        #                -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
        #                -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
        #                -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
        #                -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
        #                -0.305537695526707, -0.551540574269715],
        #               [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
        #                -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
        #                -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
        #                -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
        #                0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
        #                -2.09969534371281],
        #               [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
        #                0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
        #                0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
        #                -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
        #                -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
        #               [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
        #                1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
        #                0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
        #                -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
        #                0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
        #               [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
        #                0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
        #                -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
        #                -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
        #                -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
        #               ], dtype=np.float32)
        #
        # y = np.array([[0], [1], [0], [1], [1]])
        #
        # groups = np.array(
        #     [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])

        n_samples, n_features = X.shape
        n_grouped_features = 5
        y = np.atleast_1d(y)
        max_grouped_features = max([len(groups[i]) for i in range(len(groups))])
        min_samples_leaf = 1
        min_samples_split = 2
        min_weight_leaf = 0
        random_state = check_random_state(2547)
        max_depth = 2
        max_depth_splitting_tree = 3
        mgroup = 5
        mvar = 5
        min_impurity_decrease = 0.1
        min_impurity_split = 0.1
        min_impurity_decrease_splitting_tree = 0.1
        min_impurity_split_spltting_tree = 0.1

        if y.ndim == 1:
            y = np.reshape(y, (-1, 1))

        n_outputs = y.shape[1]

        y = np.copy(y)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y.shape, dtype=int)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, max_grouped_features, len(groups),
                                      min_samples_leaf, min_weight_leaf,
                                      random_state, max_depth_splitting_tree,
                                      min_impurity_decrease_splitting_tree,
                                      min_impurity_split_spltting_tree,
                                      mvar,
                                      mgroup)

        tree = CARTGVTree(n_grouped_features, n_classes, n_outputs)

        builder = CARTGVTreeBuilder(splitter, min_samples_split,
                                    min_samples_leaf, min_weight_leaf,
                                    max_depth, mgroup, mvar,
                                    min_impurity_decrease, min_impurity_split)

        # builder.build(tree, X.to_numpy(dtype=np.float32), y, groups, None) #X.to_numpy(dtype=np.float32)
        print("####################### TEST COMPARAISON ##############################")
        builder.test_build(tree, X.to_numpy(dtype=np.float32), y, groups)  # X.to_numpy(dtype=np.float32)

        # print(tree.nodes_group)
        # print(tree.nodes_parent)
        # print(tree.nodes_n_node_samples)
        print([(x,y) for x, y in sorted(zip(tree.nodes_parent, tree.nodes_n_node_samples))])
        print([(x,y) for x, y in sorted(zip(tree.nodes_parent, tree.nodes_group))])

        print(np.sum(tree.nodes_n_node_samples[np.where(tree.nodes_parent == 0)]))

        print(tree.nodes_impurities)
        print(len(tree.nodes_impurities))
        print(tree.node_count)

        R_n_nodes_samples_df = pd.read_csv('../Code_R/R_n_nodes_samples.csv', sep="\t", dtype=int, header=None)

        print(len(np.bincount(R_n_nodes_samples_df.iloc[:].to_numpy().flatten())))
        print(len(np.bincount(np.array(tree.nodes_n_node_samples, dtype=int))))

        self.assertSequenceEqual(np.bincount(R_n_nodes_samples_df.iloc[:].to_numpy().flatten()).tolist(),
                                 np.bincount(np.array(tree.nodes_n_node_samples, dtype=int)).tolist())



    def test_CARTTree(self):
        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        # groups = np.array([[i] for i in range(len(X.columns))])

        # X = np.array([[-0.962564615251298, -0.0818379297761482, -0.257129359665299, -1.20057124658537,
        #                -1.67321037673198, -0.850857878613548, -1.12636943482486, 0.264691871869928, 0.823490524418768,
        #                -0.289267055667413, 0.375612134943435, 0.689033636785644, -0.0755870733096488,
        #                -0.253686040025422, -0.767686310824219, -0.47706960213735, 0.619681515116366, -0.718706304417254,
        #                -0.625998377401577, 0.595352830214443, -0.826055466109155, 0.841770278364141, 0.525998122722698,
        #                -0.305537695526707, -0.551540574269715],
        #               [-0.0170226173861495, -0.575187308059669, -0.0550716676440694, -0.596082039595892,
        #                -0.153767849941737, -0.152659395126548, 0.103284766044348, 0.945962098961183, 0.11395628892521,
        #                -1.0314335555107, -0.24180964927081, -0.225116148572662, 1.75090409682049, 0.276212128428595,
        #                -0.226985192750251, -0.688321496802469, 0.721869146316049, -0.0427129520106458, 1.71093452174155,
        #                0.440414655312213, -0.219061974136534, 0.370516601227188, -0.579953711046926, -2.4756697600574,
        #                -2.09969534371281],
        #               [0.859846852829686, -0.196768997920202, -0.665097766775893, 1.49845086392502, 0.712519776986412,
        #                0.63382801135412, 0.338132006534241, -1.17912479597116, 0.337710921150664, -0.404533729530606,
        #                0.984579714687047, -1.16236566382262, -0.786198019602607, -0.753822112046281, -0.811264249392465,
        #                -0.594151853267325, -0.322916128201519, -1.2934117213506, 0.531732629482942, -1.6136606736686,
        #                -1.27887838930757, 0.678437793765498, -1.19080597429513, 1.11533360829611, -0.340409112584892],
        #               [-1.46244895844162, 0.508777691805245, -0.42599215315616, -0.570342024814983, -1.13004768682085,
        #                1.12406519881936, 0.251809560422478, -2.06632443310484, -1.23862336004496, 1.6527814698557,
        #                0.336827946772908, -0.233201791535758, 0.590072797080428, 1.7453946472635, 1.02016573606479,
        #                -0.813457453508146, -0.0745696971758758, 2.89463767013771, 0.158622453385045, -1.70880561223817,
        #                0.132671092412739, -0.479946273307748, 0.11444508132886, 1.40287375218729, -0.344499428025485],
        #               [-0.383681631574503, 1.19713456197882, -0.302078922002226, -0.544313316070517, 1.11301409047452,
        #                0.0643648126207925, 0.623795834834719, 0.288528481567621, -0.618352387217919, -0.180420032776369,
        #                -0.974252399377197, -0.78154085269986, 0.673878430962106, -0.14493184535421, -1.58840476437875,
        #                -0.89040398934659, -0.464336091106138, -0.804400496705168, 0.542582301058101, -0.213424538311193,
        #                -0.925675256270349, 0.306707969484467, 0.378645850648093, 0.220134583700443, -0.0925601673405935]
        #               ], dtype=np.float32)

        # y = np.array([[0], [1], [0], [1], [1]])

        sample_size = 5
        nb_first_variable = 1

        X = X.head(sample_size).to_numpy(dtype=np.float32)

        for i in range(nb_first_variable): #X.shape[1]
            X_one_variable = []
            for j in range(len(X[:,i])):
                X_one_variable.append([X[j,i]])
            print("### VARIABLE " + str(i) + "###")

            X_one_variable = np.array(X_one_variable, dtype=np.float32)

            y_np = y.head(sample_size).to_numpy(dtype=np.intp)

            groups = np.array([[i] for i in range(len(X_one_variable[0]))])
            len_groups = np.array([len(group) for group in groups])
            print(len_groups)

            n_samples, n_features = X.shape
            y_np = np.atleast_1d(y_np)
            min_samples_leaf = 1
            min_samples_split = 2
            min_weight_leaf = 0
            random_state = check_random_state(2547)
            max_depth = 2
            max_depth_splitting_tree = 1
            mgroup = 1
            mvar = 1 #max([len(groups[i]) for i in range(len(groups))])
            min_impurity_decrease = 0.0
            min_impurity_split = 0.0
            min_impurity_decrease_splitting_tree = 0.0
            min_impurity_split_spltting_tree = 0.0

            if y_np.ndim == 1:
                y_np = np.reshape(y_np, (-1, 1))

            n_outputs = y_np.shape[1]

            y_np = np.copy(y_np)

            classes = []
            n_classes = []

            y_encoded = np.zeros(y_np.shape, dtype=int)
            for k in range(n_outputs):
                classes_k, y_encoded[:, k] = np.unique(y_np[:, k], return_inverse=True)
                classes.append(classes_k)
                n_classes.append(classes_k.shape[0])

            y_np = y_encoded

            n_classes = np.array(n_classes, dtype=np.intp)

            criterion = CARTGVGini(n_outputs, n_classes)

            splitter = BestCARTGVSplitter(criterion, len(groups),
                                          min_samples_leaf, min_weight_leaf,
                                          random_state, max_depth_splitting_tree,
                                          min_impurity_decrease_splitting_tree,
                                          min_impurity_split_spltting_tree,
                                          mvar,
                                          mgroup)

            tree = CARTGVTree(len(groups), len_groups, n_classes, n_outputs)

            builder = CARTGVTreeBuilder(splitter, min_samples_split,
                                        min_samples_leaf, min_weight_leaf,
                                        max_depth, min_impurity_decrease, min_impurity_split)

            # builder.build(tree, X.to_numpy(dtype=np.float32), y, groups, None) #X.to_numpy(dtype=np.float32)
            print("####################### TEST CARTTREE ##############################")

            builder.test_build(tree, X_one_variable, y_np, groups, len_groups, "root")  # X.to_numpy(dtype=np.float32)

            clf = DecisionTreeClassifier(max_depth=max_depth, random_state=None, max_features=None,
                                         max_leaf_nodes=X_one_variable.shape[0]
                                         )
            clf.fit(X_one_variable,y_np)

            print(tree.node_count)
            print(np.count_nonzero(tree.nodes_n_childs)) # Number of leaves of CARTGVTree
            print(clf.tree_.node_count)
            print(clf.get_n_leaves())

            print(tree.nodes_impurities)
            print(clf.tree_.threshold)

            fig, ax = plt.subplots(2, figsize=(16, 9))
            plot_tree(clf, ax=ax[0])

            clf.tree_ = tree.nodes_splitting_trees[0]

            plot_tree(clf, ax=ax[1])
            plt.show()

    def test_CARTTree_2(self):
        df = pd.read_csv('CARTGV/data_Mael.csv', sep=";", index_col=0)

        train = df.loc[df['Type'] == 'train']

        X = train.iloc[:, 2:]

        y = train['Y']

        # groups = np.array([[i] for i in range(len(X.columns))])

        sample_size = 334
        start_var = 0
        end_var = 25

        g1_idx = [col for col in range(len(X.columns)) if '_G1' in X.columns[col]]
        g2_idx = [col for col in range(len(X.columns)) if '_G2' in X.columns[col]]
        g3_idx = [col for col in range(len(X.columns)) if '_G3' in X.columns[col]]
        g4_idx = [col for col in range(len(X.columns)) if '_G4' in X.columns[col]]
        g5_idx = [col for col in range(len(X.columns)) if '_G5' in X.columns[col]]

        groups = np.array([g1_idx, g2_idx, g3_idx, g4_idx, g5_idx])

        X = X.head(sample_size).to_numpy(dtype=np.float32)

        # X = X[:,start_var:end_var]

        y_np = y.head(sample_size).to_numpy(dtype=np.intp)

        print(y_np)

        # groups = np.array([[i] for i in range(len(X[0]))])
        # groups = np.array([np.arange(end_var-start_var)])
        len_groups = np.array([len(group) for group in groups])
        print(groups)
        print(len_groups)

        n_samples, n_features = X.shape
        y_np = np.atleast_1d(y_np)
        min_samples_leaf = 1
        min_samples_split = 2
        min_weight_leaf = 0
        random_state = check_random_state(2547)
        max_depth = 2
        max_depth_splitting_tree = 3
        # mgroup = 1 #max([len(groups[i]) for i in range(len(groups))])
        mgroup = 2
        mvar = "root"
        # mvar = end_var - start_var
        min_impurity_decrease = 0.0
        min_impurity_split = 0.0
        min_impurity_decrease_splitting_tree = 0.0
        min_impurity_split_spltting_tree = 0.0

        if y_np.ndim == 1:
            y_np = np.reshape(y_np, (-1, 1))

        n_outputs = y_np.shape[1]

        y_np = np.copy(y_np)

        classes = []
        n_classes = []

        y_encoded = np.zeros(y_np.shape, dtype=int)
        for k in range(n_outputs):
            classes_k, y_encoded[:, k] = np.unique(y_np[:, k], return_inverse=True)
            classes.append(classes_k)
            n_classes.append(classes_k.shape[0])

        y_np = y_encoded

        n_classes = np.array(n_classes, dtype=np.intp)

        criterion = CARTGVGini(n_outputs, n_classes)

        splitter = BestCARTGVSplitter(criterion, len(groups),
                                      min_samples_leaf, min_weight_leaf,
                                      random_state, max_depth_splitting_tree,
                                      min_impurity_decrease_splitting_tree,
                                      min_impurity_split_spltting_tree,
                                      mvar,
                                      mgroup)

        tree = CARTGVTree(len(groups), len_groups, n_classes, n_outputs)

        builder = CARTGVTreeBuilder(splitter, min_samples_split,
                                    min_samples_leaf, min_weight_leaf,
                                    max_depth, min_impurity_decrease, min_impurity_split)

        # builder.build(tree, X.to_numpy(dtype=np.float32), y, groups, None) #X.to_numpy(dtype=np.float32)
        print("####################### TEST CARTTREE 2 ##############################")
        builder.test_build(tree, X, y_np, groups, len_groups, None)  # X.to_numpy(dtype=np.float32)

        clf = DecisionTreeClassifier(max_depth=max_depth, random_state=None, max_features=None,
                                     max_leaf_nodes=X.shape[0]
                                     )
        clf.fit(X,y_np)

        print(tree.node_count)
        print(np.count_nonzero(tree.nodes_n_childs)) # Number of leaves of CARTGVTree
        print(clf.tree_.node_count)
        print(clf.get_n_leaves())

        print(tree.nodes_impurities)
        # print(clf.tree_.threshold)

        fig, ax = plt.subplots(2, figsize=(16, 9))
        plot_tree(clf, ax=ax[0])

        clf.tree_ = tree.nodes_splitting_trees[0]

        plot_tree(clf, ax=ax[1])
        plt.show()

if __name__ == '__main__':
    unittest.main()